/**
* Performs post-game cryptographic analysis of a single poker hand/round. Data from an associated smart contract may also be included for analysis.
*
* (C)opyright 2014 to 2017
*
* This source code is protected by copyright and distributed under license.
* Please see the root LICENSE file for terms and conditions.
*
*/

package {

	import flash.events.EventDispatcher;
	import events.PokerGameVerifierEvent;
	import PokerCardGame;
	import PokerBettingModule;
	import crypto.SRAKey;
	import crypto.SRAMultiKey;
	import crypto.interfaces.ISRAKey;
	import crypto.interfaces.ISRAMultiKey;	
	import interfaces.IPokerHand;
	import org.cg.interfaces.ICardDeck;
	import org.cg.interfaces.ICard;
	import PokerHand;
	import interfaces.IPokerPlayerInfo;
	import org.cg.DebugView;
	import p2p3.workers.CryptoWorkerHost;
	import p2p3.workers.events.CryptoWorkerHostEvent;
	import p2p3.workers.WorkerMessage;
	import org.cg.WorkerMessageFilter;
	import PokerHandAnalyzer;
	import org.cg.SmartContract;
	import org.cg.SmartContractDeferState;
	import flash.utils.setTimeout;
	
	public class PokerGameVerifier extends EventDispatcher {
		
		//Counter used to identify the number of verifier instances created since application start-up (not the number of currently active instances).
		private static var _verifierInstances:uint = 0;
		
		//List of all players, in betting order. Contains "peerID" and "ethereumAccount". May not be populated until end game.
		protected var _players:Vector.<Object> = null;
		//List of all non-folded players, in betting order. Contains "peerID" and "ethereumAccount". May not be populated until end game.
		protected var _nfPlayers:Vector.<Object> = null;
		//Card mappings copied from the current card deck.
		protected var _cardMaps:Vector.<Object> = null; 
		//Hand/combination definitions (usually supplied from game config data)
		protected var _handDefinitions:XML = null;
		//Ordered list of plaintext/face-up cards, as generated by the dealer.
		protected var _plaintextCards:Vector.<String> = new Vector.<String>();
		//List of all fully-encrypted cards (deck)
		protected var _encryptedCards:Vector.<String> = new Vector.<String>();
		//Selected encrypted cards stored by player peer ID (_privateCardSelections[peerID][0], and _privateCardSelections[peerID][1])
		protected var _privateCardSelections:Object = new Object();
		//Encrypted public card selections by dealer
		protected var _publicCardSelections:Vector.<String> = new Vector.<String>();
		//Decrypted public cards		
		protected var _publicCards:Vector.<ICard> = new Vector.<ICard>();
		//Decrypted private cards (_privateCards[peerID]=Vector.<ICard>)
		protected var _privateCards:Object = new Object();
		//Multiple crypto keychains stored by peer ID per re-key (_playerKeys[peerID] = [ISRAMultiKey (initial),ISRAMultiKey (re-key 1),...])
		protected var _playerKeys:Object = new Object();
		//Mapping of encrypted -> decrypted card values (_decryptMaps[encyptedValue]=decryptedValue)
		protected var _decryptMaps:Object = new Object();
		//Players' reported hands (used to verify against calculated results). Contains "value" property (of highest hand), and (highest) "cards" array of plaintext mappings.
		protected var _reportedPlayerHand:Object = new Object();
		//Peer ID of the reported winning player, to be verified at the end.
		protected var _reportedWinner:String; 
		//Peer ID of the winning player as calculated during verification.
		protected var _winner:String; 
		//Hand value, or score, of the winning player's best hand
		protected var _winningScore:Number = -1;
		//Best player hand, stored as ICard implementation instances by peer ID (_bestPlayerHand[peerID][#] = ICard)
		protected var _playerBestHand:Object = new Object();
		//True if the current instance is in the process of asynchronously verifying the game.
		protected var _verifying:Boolean = false;		
		protected var _messageFilter:WorkerMessageFilter;
		//Carry-through information used during decryption / verification
		protected var _verifyInfo:Object;
		//Hand analyses of decrypted hands. Each object contains "peerID" and "analyzer" (points to a PokerHandAnalyzer instance).
		protected var _handAnalyses:Vector.<Object> = new Vector.<Object>();
		
		private var _game:PokerCardGame = null;
		private var _selfPeerID:String = null; //local/self peer ID at the time that verifier's data was set
		private var _contract:SmartContract = null; //main PokerHandData contract
		private var _resolutionsContract:SmartContract// PokerHandResolutionsContract
		private var _autoPopulateContractData:Boolean = true; //should verifier be automatically populated with smart contract data on first verification fail?
		private var _usingContractData:Boolean = false; //is current verification using contract data (as opposed to game client data)?
		private var _cancelL1Validation:Boolean = false;
		private var _verified:Boolean = false;
		private var _instanceNum:uint = 0; //current instance number (getter "instanceNum" available)
		
		/**
		 * Creates a new instance.
		 */
		public function PokerGameVerifier() {
			_verifierInstances++;
			this._instanceNum = _verifierInstances;
			super(this);
		}
		
		/**
		 * @return True if the insstance is currently in the processing of verifying.
		 */
		public function get verifying():Boolean {
			return (this._verifying);
		}
		
		/**
		 * @return Returns the smart contract associated with the verifier instance, if used.
		 */
		public function get contract():SmartContract {
			return (this._contract);
		}
		
		/**
		 * The unique instance number of this verifier instance. This value is always reset at application startup.
		 */
		public function get instanceNum():uint {
			return (this._instanceNum);
		}
		
		/**
		 * The peer ID of the reported winner of the hand.
		 */
		public function get reportedWinner():String {
			return (this._reportedWinner);
		}
		
		/**
		 * The peer ID of the verified winner of the hand.
		 */
		public function get winner():String {
			return (this._winner);
		}
		
		/**
		 * @return The verified or calculated best hand score of the winning player.
		 */
		public function get winningScore():Number {
			return (this._winningScore);
		}
		
		/**
		 * @return A vector array of objects each containing a "peerID" and "analyzer" (PokerHandAnalyzer) of verified results, or null if
		 * no analyses have yet been performed.
		 */
		public function get handAnalyses():Vector.<Object> {
			return (this._handAnalyses);
		}
		
		/**
		 * Returns the reported results and hand for a specific peer.
		 * 
		 * @param	peerID The peer ID for which to retrieve the reported hand data.
		 * 
		 * @return On object containins the reported hand "value" or score (Number) and array of "cards". Each card object contains the properties:
		 * 
		 * mapping (String): The plaintext mapping value of the card
		 * cardName (String): The full name of the card
		 * frontClassName (String): The name of the class to be used to generate the card front image
		 * faceColor (String): The colour of the card ("red" or "black")
		 * faceText (String): The text representation of the card value ("ace", "two", "three", .... "jack", "queen", "king")
		 * faceValue (int): The numeric value of the card. Ace=1 or 14, Two=2, Three=3, Four=4 ... Jack=11, Queen=12, King=13
		 * 			This value should not be assumed to be an "int" type and should be cast to an appropriate type prior to any numeric operations.
		 * faceSuit (String): The card's suit ("hearts", "diamonds", "clubs", or "spades")
		 * 
		 * The values above should match the attributes of the card definitions (<cards> node) in the game settings XML data. Because these values are reported
		 * they may not exist or may be of the wrong type -- strong checking prior to use of any value is strongly recommended. The reported values may also
		 * be false and may not match verified results. Null is returned if no hand results have been reported for the peer ID.
		 */
		public function getReportedResult(peerID:String):Object {
			if (this._reportedPlayerHand[peerID] == undefined) {
				return (null);
			}
			return (this._reportedPlayerHand[peerID]);
		}		
		
		/**
		 * Returns the PokerhandAnalyzer instance used to evaluate the hand for a specific peer.
		 * 
		 * @param	peerID The peer ID for which to retrieve the PokerHandAnalyzerInstance.
		 * 
		 * @return The PokerHandAnalyzer instance for the peer ID or null if one doesn't exist (for example, analysis hasn't yet completed).
		 */
		public function getAnalyzer (peerID:String):PokerHandAnalyzer {
			for (var count:int = 0; count < this._handAnalyses.length; count++) {
				var currentObj:Object = this._handAnalyses[count]
				if (currentObj.peerID == peerID) {
					return (currentObj.analyzer);
				}
			}
			return (null);
		}
		
		/**
		 * Copies all required data from a source PokerCardGame instance.
		 * 
		 * @param	game The PokerCardGame instance from which to copy contract, player, card, and hand definition data.
		 */
		public function setAllData(game:PokerCardGame):void {
			this._game = game;
			this._contract = game.activeSmartContract;
			this._resolutionsContract = game.resolutionsContract;
			this._selfPeerID = game.clique.localPeerInfo.peerID;
			this.setPlayers(game.bettingModule);
			this.setCardMappings(game.currentDeck);
			this.setHandDefinitions(game.settings["getSettingsCategory"]("hands"));			
		}
		
		/**
		 * Assigns the active (non-folded) players from a currently active betting module to the verifier.
		 * It's best to do this at the end of a game when only non-folded players are remaining.
		 * 
		 * @param	bettingModule The PokerBettingModule instance from which to retrieve player data.
		 */
		public function setPlayers(bettingModule:PokerBettingModule):void {
			var allPlayers:Vector.<IPokerPlayerInfo> = bettingModule.allPlayers; //include folded players
			var nfPlayers:Vector.<IPokerPlayerInfo> = bettingModule.nonFoldedPlayers; //include folded players
			if (allPlayers == null) {
				return;
			}
			if (nfPlayers == null) {
				return;
			}
			if (bettingModule.winningPlayerInfo != null) {
				this._reportedWinner = bettingModule.winningPlayerInfo.netCliqueInfo.peerID;
			}
			this._players = new Vector.<Object>();
			for (var count:int = 0; count < allPlayers.length; count++) {
				var playerObj:Object = new Object();
				playerObj.peerID = allPlayers[count].netCliqueInfo.peerID;
				if (bettingModule.game.ethereum != null) {
					playerObj.ethereumAccount = bettingModule.game.ethereum.getAccountByPeerID(playerObj.peerID);
				} else {
					playerObj.ethereumAccount = "0x";
				}
				this._players.push(playerObj);
			}					
			this._nfPlayers = new Vector.<Object>();
			for (count = 0; count < nfPlayers.length; count++) {
					playerObj = new Object();
					playerObj.peerID = nfPlayers[count].netCliqueInfo.peerID;
					if (bettingModule.game.ethereum != null) {
						playerObj.ethereumAccount = bettingModule.game.ethereum.getAccountByPeerID(playerObj.peerID);
					} else {
						playerObj.ethereumAccount = "0x";
					}
					this._nfPlayers.push(playerObj);
				}			
		}
		
		/**
		 * Sets internal card mappings from an ICardDeck implementation instance.
		 * 
		 * @param	currentDeck The deck instance from which to copy card mappings.
		 */
		public function setCardMappings(currentDeck:ICardDeck):void {
			this._cardMaps = currentDeck.duplicateCardMap();			
		}
		
		/**
		 * Sets internal hand definition data (e.g. hand definitions from global config data).
		 * 
		 * @param	definitions The XML hand definitions to set.
		 */
		public function setHandDefinitions(definitions:XML):void {
			this._handDefinitions = definitions;
		}		
		
		/**
		 * Stores a plaintext card value from the face-up/un-encrypted deck for verification.
		 * 
		 * @param	cardValue The card value to store.
		 */
		public function addPlaintextCard(cardValue:String):void {
			this._plaintextCards.push(cardValue);
		}
				
		/**
		 * Stores a fully-encrypted/face-down card value for verification.
		 * 
		 * @param	cardValue The card value to store.
		 */
		public function addEncryptedCard(cardValue:String):void {
			this._encryptedCards.push(cardValue);			
		}
		
		/**
		 * Stores a fully-encrypted/face-down private or hole card selection for a player, for verification.
		 * 
		 * @param	sourcePeerID The peer ID of the player to store the card for.
		 * @param	cardValue The encrypted card value to store.
		 */
		public function addPrivateCardSelection(sourcePeerID:String, cardValue:String):void {
			if ((this._privateCardSelections[sourcePeerID] == undefined) || (this._privateCardSelections[sourcePeerID] == null)) {
				this._privateCardSelections[sourcePeerID] = new Array();
			}
			this._privateCardSelections[sourcePeerID].push(cardValue);
		}
		
		/**
		 * Stores a fully-encrypted/face-down public or community card selection for verification.
		 * 
		 * @param	cardValue The encrypted card value to store.
		 */
		public function addPublicCardSelection(cardValue:String):void {
			this._publicCardSelections.push(cardValue);
		}
		
		/**
		 * Stores the encryption and decryption keys for a specific player.
		 * 
		 * @param	sourcePeerID The peer ID of the player to store the keychain for.
		 * @param	keys An ISRAMultiKey implementation storing the player's keychain.
		 */
		public function addPlayerKeys(sourcePeerID:String, keys:ISRAMultiKey):void {
			DebugView.addText("PokerGameVerifier.addPlayerKeys");
			if ((this._playerKeys[sourcePeerID] == undefined) || (this._playerKeys[sourcePeerID] == null)) {
				this._playerKeys[sourcePeerID] = new Array();
			}			
			if (this._playerKeys[sourcePeerID].length==0) {
				this._playerKeys[sourcePeerID].push(keys);
			}  else {
				//TODO: investigate (this shouldn't happen)!
				DebugView.addText ("   Attempt to add new keys to instance #" + this._instanceNum+"! Aborting.");
			}			
		}
		
		/**
		 * Adds the player's stated results, as send in the payload data of a PokerBettingMessage.PLAYER_RESULTS message.
		 * The stated results will be compared against the actual results during verification.
		 * 
		 * @param	resultsObj The results data for the player. See the payload definition of the PokerBettingMessage.PLAYER_RESULTS
		 * for expected data.
		 */
		public function addPlayerResults(sourcePeerID:String, resultsObj:Object):void {
			DebugView.addText ("PokerGameVerifier.addPlayerResults (child: " + _game.lounge.isChildInstance+")");
			DebugView.addText ("   For peer: " + sourcePeerID);
			DebugView.addText ("   self: " + _game.clique.localPeerInfo.peerID);
			//add crypto keys; resultsObj.keys.length > 1 for dropout/re-key games
			for (var count:int = 0; count < resultsObj.keys.length; count++) {
				var currentKeySet:Array = resultsObj.keys[count];
				var keys:Vector.<SRAKey> = new Vector.<SRAKey>();
				for (var count2:int = 0; count2 < currentKeySet.length; count2++) {
					var currentKeyInfo:Object = resultsObj.keys[count][count2];
					keys.push(new SRAKey(currentKeyInfo.encKey, currentKeyInfo.decKey, currentKeyInfo.mod));
				}
				this.addPlayerKeys(sourcePeerID, new SRAMultiKey(keys));
			}
			if (this._reportedPlayerHand == null) {
				this._reportedPlayerHand = new Object();
			}
			this._reportedPlayerHand[sourcePeerID] = new Object();
			this._reportedPlayerHand[sourcePeerID].value = Number(resultsObj["hands"][0].value);			
			this._reportedPlayerHand[sourcePeerID].cards = new Array();
			for (count = 0; count < resultsObj["hands"][0].matchedHand.length; count++) {
				this._reportedPlayerHand[sourcePeerID].cards = resultsObj["hands"][0].matchedHand[count];
			}			
		}
		
		/**
		 * Performs a phase defer check for the verifier.
		 * 
		 * @param	deferObj A SmartContractDeferState instance being used for the phase defer check.
		 * 
		 * @return True if the correct phase(s) in the target smart contract has been achieved, false otherwise.
		 */
		public function phaseDeferCheck(deferObj:SmartContractDeferState):Boolean {	
			var requiredPhase:uint = uint(deferObj.data.phase);
			var phaseFound:Boolean = true;				
			for (var count:int = 0; count < this._players.length; count++) {				
				var currentPeerID:String  = this._players[count].peerID;
				var account:String = this._players[count].ethereumAccount;
				var phaseString:String = this._contract.toString.phases(account);
				var phase:uint = uint(phaseString);					
				if (phase != requiredPhase) {
					phaseFound = false;
				}
			}				
			return (phaseFound);
		}
		
		/**
		 * Performs a completion defer check for the verifier.
		 * 
		 * @param	deferObj A SmartContractDeferState instance being used for the complettion defer check.
		 * 
		 * @return True if the contract's "complete" flag is true, false otherwise.
		 */
		public function completeDeferCheck(deferObj:SmartContractDeferState):Boolean {	
			return (deferObj.operationContract.toBoolean.complete());
		}
		
		/**
		 * Begins monitoring the contract for its "complete" state, usually when verification/validation has successfully completed.
		 * When the associated contract is complete the verifier's "destroy" method is invoked.
		 * 		 
		 */
		public function clearOnComplete():void {			
			var defer:SmartContractDeferState = new SmartContractDeferState(this.completeDeferCheck, null, this, true);				
			defer.operationContract = this._contract;
			if (defer.complete == false) {
				setTimeout(this.clearOnComplete, this._contract.deferInterval);				
			} else {
				this.destroy();
			}
		}
		
		/**
		 * Initiates a Level 1 validation on the smart _contract reference. If no smart contract is in use then this function does nothing. All
		 * data and verifications must be complete prior to calling this function.
		 * 
		 * @param waitForPhase If greater than 0 this function will perform a phase deferral check at regular intervals (as set in the associated
		 * smart contract's "deferInterval" property), before attempting to continue,
		 * otherwise it will be executed immediately.
		 * @param deferred True if the current invocation is deferred (waiting), false if this is the first time call. This value is used internally
		 * and should not be set by external callers.
		 * 
		 * @returns True if Level 1 smart contract validation was sucessfull started, false otherwise (e.g. contract is not at the right phase or L1
		 * validation was cancelled).
		 */
		public function L1Validate(waitForPhase:uint = 15, deferred:Boolean = false):Boolean {
			if ((this._contract == null) || ((this._cancelL1Validation) && (deferred == true))) {
				//only cancel if current call is deferred
				this._cancelL1Validation = false;
				return (false);
			}
			this._cancelL1Validation = false;			
			if (waitForPhase > 0) {
				var deferDataObj:Object = new Object();
				deferDataObj.phase = waitForPhase;								
				//use internal defer check function since player list may have already changed in game
				var defer:SmartContractDeferState = new SmartContractDeferState(this.phaseDeferCheck, deferDataObj, this, true);				
				defer.operationContract = this._contract;
				if (defer.complete == false) {				
					defer = null;
					deferDataObj = null;
					setTimeout(this.L1Validate, this._contract.deferInterval, waitForPhase, true);
					return (false);
				}				
				//contract is at appropriate phase
				defer = null;
				deferDataObj = null;
			}
			DebugView.addText("PokerGameVerifier.L1Validate");
			try {
				var encKeys:Array = new Array();
				var decKeys:Array = new Array();
				var bestCards:Array = new Array();
				var keychain:Array = this._playerKeys[this._selfPeerID];
				for (var count:int = 0; count < keychain.length; count++) {
					var currentKeys:ISRAMultiKey = keychain[count] as ISRAMultiKey;
					for (var count2:int = 0; count2 < currentKeys.numKeys; count2++) {
						var currentKey:ISRAKey = currentKeys.getKey(count2);
						encKeys.push(currentKey.encKeyHex);
						decKeys.push(currentKey.decKeyHex);
					}
				}
				var analyzer:PokerHandAnalyzer = this.getPokerHandAnalyzerFor(this._selfPeerID);				
				var bestHand:Vector.<ICard> = analyzer.highestHand.matchedHand;
				for (count = 0; count < bestHand.length; count++) {
					var currentCard:ICard = bestHand[count];					
					var contractCardIndex:int = this.getContractValidationIndex(this.getEncryptedValue(this.getCardMapping(currentCard)), this._contract.account);					
					if (contractCardIndex > -1) {
						bestCards.push(contractCardIndex);
					} else {
						DebugView.addText ("   Couldn't generate validation index for card: " + currentCard.cardName);
						DebugView.addText ("   Plaintext card mapping: " + this.getCardMapping(currentCard));
						DebugView.addText ("   Fully encrypted value: " + this.getEncryptedValue(this.getCardMapping(currentCard)));
						return (false)
					}
				}				
				DebugView.addText("             Contract address: " + this._contract.address);
				DebugView.addText("      Storing encryption keys: " + encKeys);
				DebugView.addText("      Storing decryption keys: " + decKeys);
				DebugView.addText("   Storing best cards indexes: " + bestCards);				
				this._resolutionsContract.L1Validate(this._contract.address, encKeys, decKeys, bestCards).invoke({from:this._contract.account, gas:2000000});
				return (true);
			} catch (err:*) {
				DebugView.addText("PokerGameVerifier.L1Validate error:");
				DebugView.addText(err.getStackTrace());
			}
			return (false);
		}
		
		/**
		 * Cancels a deferred Level 1 validation invocation if active. If no Level 1 validation is currently being deferred, this function does nothing.
		 */
		public function cancelL1Validate():void {
			this._cancelL1Validation = true;
		}
		
		/**
		 * Begins the process of asynchronous game verification using all currently provided data. All input functions
		 * are disabled until the verification produces a result.
		 * 
		 * @param If true, verifier automatically populates itself with data from the contract if a verification fails the first time. If false
		 * only game client data is used for verification.
		 */
		public function verify(autoPopulateContractData:Boolean = true):void {
			if (this._verifying) {
				return;
			}
			this._autoPopulateContractData = autoPopulateContractData;
			this._verified = false;
			DebugView.addText("PokerGameVerifier.verify");
			if (this._players == null) {
				DebugView.addText("   No players exist to verify. Either game doesn't exist or all but one players have folded.");
				return;
			}
			DebugView.addText("-----------");
			DebugView.addText("   Included peer Ids / Ethereum accounts: " );
			for (var count:int = 0; count < this._players.length; count++) {
				DebugView.addText("      " + this._players[count].peerID);
				DebugView.addText("     / " + this._players[count].ethereumAccount);
			}
			DebugView.addText("-----------");
			DebugView.addText("   Plaintext cards (mappings): " );
			for (count = 0; count < this._plaintextCards.length; count++) {
				DebugView.addText("      " + this._plaintextCards[count]);				
			}
			DebugView.addText("-----------");
			DebugView.addText("   Encrypted cards (full deck): " );
			for (count = 0; count < this._encryptedCards.length; count++) {
				DebugView.addText("      " + this._encryptedCards[count]);				
			}
			DebugView.addText("-----------");
			DebugView.addText("   Peer Id -> Encrypted private card selections: " );			
			for (count = 0; count < this._players.length; count++) {
				var currentPlayerID:String = this._players[count].peerID;
				DebugView.addText ("   Peer: " + currentPlayerID + " ->");
				if ((this._privateCardSelections[currentPlayerID] != undefined) && (this._privateCardSelections[currentPlayerID]!=null)) {
					for (var count2:int = 0; count2 < this._privateCardSelections[currentPlayerID].length; count2++) {
						DebugView.addText("         Card #"+count2+":" + this._privateCardSelections[currentPlayerID][count2]);
					}			
				} else {
					DebugView.addText ("         No matching private card selections found!");
				}
			}
			DebugView.addText("-----------");
			DebugView.addText("   Encrypted public card selections: " );			
			for (count = 0; count < this._publicCardSelections.length; count++) {
				DebugView.addText ("      " + this._publicCardSelections[count]);
			}
			DebugView.addText("   Peer Id -> Key pairs chain: " );
			for (count = 0; count < this._players.length; count++) {
				currentPlayerID = this._players[count].peerID;
				DebugView.addText ("      Peer: " + currentPlayerID + " ->");
				if (this._playerKeys[currentPlayerID] != undefined) {
					DebugView.addText ("         Number of keysets/multikeys: "+this._playerKeys[currentPlayerID].length);
					for (count2 = 0; count2 < this._playerKeys[currentPlayerID].length; count2++) {
						try {
							var keys:ISRAMultiKey = ISRAMultiKey(this._playerKeys[currentPlayerID][count2]);						
							for (var count3:int = 0; count3 < keys.numKeys; count3++) {
								DebugView.addText("               Encryption key: " + keys.getKey(count3).encKeyHex);
								DebugView.addText("               Decryption key: " + keys.getKey(count3).decKeyHex);
								DebugView.addText("               Modulus: " + keys.getKey(count3).modulusHex);
							}
						} catch (err:*) {
							DebugView.addText ("      Couldn't cast to ISRAMultiKey implementation!");
						}
					}
				}				
			}
			DebugView.addText("-----------");
			this._decryptMaps = new Object();				
			this._winner = "";		
			this._winningScore = -1;
			this._playerBestHand = new Object();		
			this._verifyInfo = new Object();		
			this._handAnalyses = new Vector.<Object>();
			this._verifying = true;			
			this.verifyCardValues();
		}
		
		/**
		 * Populates the verifier's data from the associated smart contract, usually if verification failed.
		 */
		private function populateFromContract():void {
			DebugView.addText ("PokerGameVerifier.populateFromContract");			
			this._privateCardSelections = new Object();
			this._publicCardSelections = new  Vector.<String>();
			for (var count:int = 0; count < this._players.length; count++) {
				var currentPlayerObj:Object = this._players[count];
				var currentAccount:String = currentPlayerObj.ethereumAccount;
				DebugView.addText("   Populating data for account (peerID): " + currentAccount + " ("+currentPeerID+")");
				var currentPeerID:String = currentPlayerObj.peerID;		
				for (var count2:int = 0; count2 < 2; count2++) {
					var cardValue:String = this._contract.toHex.privateCards(currentAccount, count2);
					DebugView.addText ("      Adding stored private/hole card #" + count2 + ": " + cardValue);
					this.addPrivateCardSelection(currentPeerID, cardValue);
				}
			}
			for (count = 0; count < 5; count++) {
				cardValue = this._contract.toHex.publicCards(count);
				DebugView.addText ("   Adding public/community card #" + count + ": " + cardValue);
				this.addPublicCardSelection(cardValue);
			}
			this._usingContractData = true;
			this._verifying = false;
			//add calculated plaintext values too?
			this.verify();
		}
		
		/**
		 * Begins the process of verifying all of the supplied cards. Initially card are checked for appropriate
		 * numbers (e.g. 2 private/hole cards per player, 5 public/community cards), and if this step passes
		 * decryption is started using supplied player keys.
		 */
		private function verifyCardValues():void {
			DebugView.addText("PokerGameVerifier.verifyCardValues");			
			if (this._encryptedCards.length < 52) {
				DebugView.addText("      Less than 52 encrypted cards in full deck.");
				this.onVerifyFail();
				return;
			}
			if (this._plaintextCards.length < 52) {
				DebugView.addText("      Less than 52 plaintext cards in full deck.");
				this.onVerifyFail();
				return;
			}
			DebugView.addText("   Checking public card selections for uniqueness and correctness...")			
			if (this._publicCardSelections.length < 5) {
				DebugView.addText("      Less than 5 public card selections available.");
				this.onVerifyFail();	
				return;
			}
			DebugView.addText("      Correct number of selected public cards.");
			for (var count:int = 0; count < this._publicCardSelections.length; count++) {
				var currentCard:String = this._publicCardSelections[count];
				for (var count2:int = (count+1); count2 < this._publicCardSelections.length; count2++) {
					var compareCard:String = this._publicCardSelections[count2];
					if (currentCard == compareCard) {
						DebugView.addText ("      Public card selection is not unique: " + currentCard);
						this.onVerifyFail();
						return;
					}
				}
			}
			DebugView.addText("      Public card selections are internally unique.");
			for (count = 0; count < this._publicCardSelections.length; count++) {
				currentCard = this._publicCardSelections[count];
				var found:Boolean = false;
				for (count2 = 0; count2 < this._encryptedCards.length; count2++) {
					compareCard = this._encryptedCards[count2];					
					if (currentCard == compareCard) {
						found = true;						
					}
				}
				if (!found) {
					DebugView.addText ("   Public card selection does not exist in deck: " + currentCard);
					this.onVerifyFail();
					return;
				}
			}
			DebugView.addText("      Public card selections exist in fully-encrypted deck.");
			for (count = 0; count < this._publicCardSelections.length; count++) {
				currentCard = this._publicCardSelections[count];
				for (count2 = (count + 1); count2 < this._players.length; count2++) {
					var privateCardSelections:Array = this._privateCardSelections[this._players[count2].peerID];
					for (var count3:int = 0; count3 < privateCardSelections.length; count3++) {
						compareCard = privateCardSelections[count3];
						if (currentCard == compareCard) {
							DebugView.addText ("   Public card selection conflicts with private card: " + currentCard);
							this.onVerifyFail();
							return;
						}
					}
				}
			}
			DebugView.addText("      Public card selections do not conflict with private card selections.");
			DebugView.addText("      -> All public cards pass initial verification.");
			DebugView.addText("-----------");
			DebugView.addText("      Checking private card selections for uniqueness and correctness...")
			for (count = 0; count < this._players.length; count++) {
				var currentPeerID:String = this._players[count].peerID;
				if ((this._privateCardSelections[currentPeerID] == undefined) || (this._privateCardSelections[currentPeerID] == null)) {
					DebugView.addText ("      Peer has no private card selections recorded: " + currentPeerID);
					this.onVerifyFail();
					return;
				}
				if (this._privateCardSelections[currentPeerID].length < 2) {
					DebugView.addText ("   Peer has insufficient private card selections recorded: " + this._privateCardSelections[currentPeerID].length);
					this.onVerifyFail();
					return;
				}
			}
			DebugView.addText("      All peers have the required number of private card selections.");
			var collatedSelections:Array = new Array();
			for (count = 0; count < this._players.length; count++) {
				currentPeerID = this._players[count].peerID;
				privateCardSelections = this._privateCardSelections[currentPeerID];
				for (count2 = 0; count2 < privateCardSelections.length; count2++) {
					collatedSelections.push(privateCardSelections[count2]);
				}
			}
			for (count = 0; count < collatedSelections.length; count++) {
				currentCard = collatedSelections[count];
				for (count2 = (count + 1); count2 < collatedSelections.length; count2++) {
					compareCard = collatedSelections[count2]
					if (currentCard == compareCard) {
						DebugView.addText ("   Private card selections conflicts with another: " + currentCard);
						this.onVerifyFail();
						return;
					}
				}
			}
			DebugView.addText("      All private card selections are unique.");
			for (count = 0; count < collatedSelections.length; count++) {
				currentCard = collatedSelections[count];
				found = false;
				for (count2 = 0; count2 < this._encryptedCards.length; count2++) {
					compareCard = this._encryptedCards[count2];
					if (currentCard == compareCard) {
						found = true;						
					}
				}
				if (!found) {
					DebugView.addText ("   Private card selection does not exist in encrypted deck: " + currentCard);
					this.onVerifyFail();
					return;
				}
			}
			DebugView.addText("      Private card selections are unique..");
			DebugView.addText("      -> All private cards pass initial verification.");
			DebugView.addText("-----------");
			this._decryptMaps = new Object();
			setTimeout(this.verifyPublicCards, 300);
		}
		
		/**
		 * Begins the process of verifying the cryptographic correctness of public/community cards by decrypting them
		 * using supplied player keys.
		 */
		private function verifyPublicCards():void {
			DebugView.addText("PokerGameVerifier.verifyPublicCards");
			if (this._messageFilter != null) {
				this._messageFilter.destroy();
				this._messageFilter = null;
			}
			this._messageFilter = new WorkerMessageFilter();
			this._verifyInfo = new Object();
			this._verifyInfo.decryptIndex = 0; //index of player currently decrypting
			this._verifyInfo.keychainIndex = 0; //player's current keyset/keychain
			this._verifyInfo.keyIndex = 0; //player's current key
			this._verifyInfo.cardIndex = 0; //card currently being decrypted
			this._verifyInfo.result = this._publicCardSelections[this._verifyInfo.cardIndex]; //current decryption result
			this._verifyInfo.successCount = 0; //number of successful decryptions
			this._verifyInfo.failCount = 0; //number of failed decryptions (should be 0!)
			var cryptoWorker:CryptoWorkerHost = CryptoWorkerHost.nextAvailableCryptoWorker;					
			cryptoWorker.addEventListener(CryptoWorkerHostEvent.RESPONSE, onDecryptPublicCard);			
			var currentCard:String = this._publicCardSelections[this._verifyInfo.cardIndex];			
			var currentPlayerID:String = this._players[this._verifyInfo.decryptIndex].peerID;			
			var currentKeyChain:ISRAMultiKey = this._playerKeys[currentPlayerID][this._verifyInfo.keychainIndex];			
			var currentKey:ISRAKey = currentKeyChain.getKey(this._verifyInfo.keyIndex);	
			this._decryptMaps[currentCard] = "";
			var msg:WorkerMessage = cryptoWorker.decrypt(currentCard, currentKey, 16);
			this._messageFilter.addMessage(msg);
		}
		
		/**
		 * Event listener invoked when a public/community card has been decrypted by a single key.
		 * 
		 * @param	eventObj A CryptoWorkerHostEvent object.
		 */
		private function onDecryptPublicCard(eventObj:CryptoWorkerHostEvent):void {
			if (!this._messageFilter.includes(eventObj.message, true)) {
				return;
			}
			eventObj.target.removeEventListener(CryptoWorkerHostEvent.RESPONSE, onDecryptPublicCard);
			try {
				this._verifyInfo.result = eventObj.data.result;				
				var currentCard:String = this._verifyInfo.result;				
				var currentPlayerID:String = this._players[this._verifyInfo.decryptIndex].peerID;								
				var playerKeyChains:Array = this._playerKeys[currentPlayerID];				
				var currentKeyChain:ISRAMultiKey = playerKeyChains[this._verifyInfo.keychainIndex];								
				if (playerKeyChains.length > 1) {
					this._verifying = false;
					DebugView.addText("PokergameVerifier.onDecryptPublicCard - Multiple keychain verification not yet supported! Aborting...");
					return;
				}
				this._verifyInfo.keyIndex++;
				if (this._verifyInfo.keyIndex >= currentKeyChain.numKeys) {
					this._verifyInfo.keyIndex = 0;
					//currently only the first keychain is supported for verification
					this._verifyInfo.keychainIndex++;				
				}							
				if (this._verifyInfo.keychainIndex >= playerKeyChains.length) {
					this._verifyInfo.keychainIndex = 0;
					this._verifyInfo.decryptIndex++;
				}							
				if (this._verifyInfo.decryptIndex >= this._players.length) {		
					DebugView.addText("   Public card fully decrypted: " + this._verifyInfo.result);					
					try {
						if (this.matchesPlaintextCard(this._verifyInfo.result)) {
							var card:ICard = this.getCardByMap(this._verifyInfo.result);
							DebugView.addText("   Card mapped as: " + card.cardName);
							this.mapDecryptedCard(currentCard);
							this._publicCards.push(card);
							this._verifyInfo.successCount++;
						} else {
							DebugView.addText("   No such plaintext card exists.");
							this._verifyInfo.failCount++;
						}
					} catch (err:*) {
						DebugView.addText("   Mapping of card against current deck failed.");
						this._verifyInfo.failCount++;
					}
					this._verifyInfo.decryptIndex = 0;
					this._verifyInfo.keychainIndex = 0;
					this._verifyInfo.keyIndex = 0;
					this._verifyInfo.cardIndex++;						
					if (this._verifyInfo.cardIndex >= this._publicCardSelections.length) {
						DebugView.addText ("All public cards verified:");
						DebugView.addText ("   Success:" + this._verifyInfo.successCount);
						DebugView.addText ("      Fail:" + this._verifyInfo.failCount);
						DebugView.addText("-----------");
						if (this._verifyInfo.failCount > 0) {
							this.onVerifyFail();					
						} else {
							//next part of verification
							this.verifyPrivateCards();							
						}
						return;
					} 
					currentCard = this._publicCardSelections[this._verifyInfo.cardIndex];
					this._decryptMaps[currentCard] = "";
				}				
				if (this._verifyInfo.decryptIndex < this._players.length) {
					currentPlayerID = this._players[this._verifyInfo.decryptIndex].peerID;					
					playerKeyChains = this._playerKeys[currentPlayerID];					
					currentKeyChain = playerKeyChains[this._verifyInfo.keychainIndex];					
					//continue decryption
					var cryptoWorker:CryptoWorkerHost = CryptoWorkerHost.nextAvailableCryptoWorker;						
					cryptoWorker.addEventListener(CryptoWorkerHostEvent.RESPONSE, onDecryptPublicCard);	
					var currentKey:ISRAKey = currentKeyChain.getKey(this._verifyInfo.keyIndex);	
					var msg:WorkerMessage = cryptoWorker.decrypt(currentCard, currentKey, 16);
					this._messageFilter.addMessage(msg);
				} else {
					DebugView.addText ("Current player index exceeds number of registered players! Aborting...");
				}
			} catch (err:*) {
				DebugView.addText("PokerGameVerifier.onDecryptPublicCard error:");
				DebugView.addText(err.getStackTrace());
				this.onVerifyFail();
			}
		}	
		
		/**
		 * Begins the process of verifying the cryptographic correctness of private/hole cards by decrypting them
		 * using supplied player keys.
		 */
		private function verifyPrivateCards():void {
			DebugView.addText("PokerGameVerifier.verifyPrivateCards");
			if (this._messageFilter != null) {
				this._messageFilter.destroy();
				this._messageFilter = null;
			}
			this._messageFilter = new WorkerMessageFilter();
			this._verifyInfo = new Object();
			this._verifyInfo.decryptIndex = 0; //index of player currently decrypting			
			this._verifyInfo.playersCardsIndex = 0; //player who's cards are being decrypted			
			this._verifyInfo.keychainIndex = 0; //player's current keyset/keychain
			this._verifyInfo.keyIndex = 0; //player's current key
			this._verifyInfo.cardIndex = 0; //card currently being decrypted
			var currentPlayerID:String = this._players[this._verifyInfo.playersCardsIndex].peerID;	//set this here since it's used below		
			this._verifyInfo.successCount = 0; //number of successful decryptions
			this._verifyInfo.failCount = 0; //number of failed decryptions (should be 0!)
			this._verifyInfo.result = this._privateCardSelections[currentPlayerID][0]; //current decryption result
			var cryptoWorker:CryptoWorkerHost = CryptoWorkerHost.nextAvailableCryptoWorker;					
			cryptoWorker.addEventListener(CryptoWorkerHostEvent.RESPONSE, onDecryptPrivateCard);			
			var currentCard:String = this._privateCardSelections[currentPlayerID][0];									
			var currentKeyChain:ISRAMultiKey = this._playerKeys[currentPlayerID][this._verifyInfo.keychainIndex];			
			var currentKey:ISRAKey = currentKeyChain.getKey(this._verifyInfo.keyIndex);
			this._decryptMaps[currentCard] = "";			
			var msg:WorkerMessage = cryptoWorker.decrypt(currentCard, currentKey, 16);
			this._messageFilter.addMessage(msg);
		}
		
		/**
		 * Event listener invoked when a private/hole card has been decrypted by a single key.
		 * 
		 * @param	eventObj A CryptoWorkerHostEvent object
		 */
		private function onDecryptPrivateCard(eventObj:CryptoWorkerHostEvent):void {
			if (!this._messageFilter.includes(eventObj.message, true)) {
				return;
			}
			eventObj.target.removeEventListener(CryptoWorkerHostEvent.RESPONSE, onDecryptPrivateCard);
			try {
				this._verifyInfo.result = eventObj.data.result;				
				var currentCard:String = this._verifyInfo.result;				
				var currentPlayerID:String = this._players[this._verifyInfo.decryptIndex].peerID;								
				var playerKeyChains:Array = this._playerKeys[currentPlayerID];				
				var currentKeyChain:ISRAMultiKey = playerKeyChains[this._verifyInfo.keychainIndex];								
				if (playerKeyChains.length > 1) {
					this._verifying = false;
					DebugView.addText("PokerGameVerifier.onDecryptPrivateCard - Multiple keychain verification not yet supported! Aborting...");
					return;
				}
				this._verifyInfo.keyIndex++;
				if (this._verifyInfo.keyIndex >= currentKeyChain.numKeys) {
					this._verifyInfo.keyIndex = 0;
					//currently only the first keychain is supported for verification
					this._verifyInfo.keychainIndex++;				
				}							
				if (this._verifyInfo.keychainIndex >= playerKeyChains.length) {
					this._verifyInfo.keychainIndex = 0;
					this._verifyInfo.decryptIndex++;
				}							
				if (this._verifyInfo.decryptIndex >= this._players.length) {		
					DebugView.addText("   Private card fully decrypted: " + this._verifyInfo.result);					
					try {
						if (this.matchesPlaintextCard(this._verifyInfo.result)) {
							var card:ICard = this.getCardByMap(this._verifyInfo.result);
							DebugView.addText("   Card mapped as: " + card.cardName);
							this.mapDecryptedCard(currentCard);
							var currentTargetPlayer:String = this._players[this._verifyInfo.playersCardsIndex].peerID;
							if ((this._privateCards[currentTargetPlayer] == undefined) || (this._privateCards[currentTargetPlayer] == null)) {
								this._privateCards[currentTargetPlayer] = new Vector.<ICard>();
							}
							DebugView.addText("   Storing card for player: " + currentTargetPlayer);
							this._privateCards[currentTargetPlayer].push(card);
							this._verifyInfo.successCount++;
						} else {							
							DebugView.addText("   No such plaintext card exists.");
							this._verifyInfo.failCount++;
						}
					} catch (err:*) {
						DebugView.addText("   Mapping of card against current deck failed.");
						this._verifyInfo.failCount++;
					}
					this._verifyInfo.decryptIndex = 0;
					this._verifyInfo.keychainIndex = 0;
					this._verifyInfo.keyIndex = 0;
					this._verifyInfo.cardIndex++;
					currentTargetPlayer = this._players[this._verifyInfo.playersCardsIndex].peerID;
					if (this._verifyInfo.cardIndex >= this._privateCardSelections[currentPlayerID].length) {
						DebugView.addText ("All private cards verified for: "+currentTargetPlayer);
						DebugView.addText ("   Success:" + this._verifyInfo.successCount);
						DebugView.addText ("      Fail:" + this._verifyInfo.failCount);
						DebugView.addText("-----------");
						this._verifyInfo.cardIndex = 0;						
						this._verifyInfo.playersCardsIndex++						
						if (this._verifyInfo.playersCardsIndex >= this._players.length) {							
							if (this._verifyInfo.failCount > 0) {
								this.onVerifyFail();						
							} else {
								//next part of verification
								this.scoreHands();							
							}
							return;
						}						
					}
					currentTargetPlayer = this._players[this._verifyInfo.playersCardsIndex].peerID;
					currentCard = this._privateCardSelections[currentTargetPlayer][this._verifyInfo.cardIndex];
					this._decryptMaps[currentCard] = "";
				}				
				if (this._verifyInfo.decryptIndex < this._players.length) {
					currentPlayerID = this._players[this._verifyInfo.decryptIndex].peerID;					
					playerKeyChains = this._playerKeys[currentPlayerID];					
					currentKeyChain = playerKeyChains[this._verifyInfo.keychainIndex];					
					//continue decryption
					var cryptoWorker:CryptoWorkerHost = CryptoWorkerHost.nextAvailableCryptoWorker;	
					cryptoWorker.addEventListener(CryptoWorkerHostEvent.RESPONSE, onDecryptPrivateCard);	
					var currentKey:ISRAKey = currentKeyChain.getKey(this._verifyInfo.keyIndex);	
					var msg:WorkerMessage = cryptoWorker.decrypt(currentCard, currentKey, 16);
					this._messageFilter.addMessage(msg);
				} else {
					this._verifying = false;
					DebugView.addText ("Current player index exceeds number of registered players! Aborting...");
				}
			} catch (err:*) {
				DebugView.addText("PokerGameVerifier.onDecryptPrivateCard error:");
				DebugView.addText(err.getStackTrace());				
				this.onVerifyFail();
			}
		}
		
		/**
		 * Generates best hand scores for all players using fully decrypted and mapped cards.
		 */
		private function scoreHands():void {
			DebugView.addText("PokerGameVerifier.scoreHands");			
			this._handAnalyses = new Vector.<Object>();
			this._winningScore = -1;
			try {
				//only evaluate non-folded players
				for (var count:int = 0; count < this._nfPlayers.length; count++) {
					var newObj:Object = new Object();
					var currentPeerID:String = this._nfPlayers[count].peerID;
					var privateCards:Vector.<ICard> = this._privateCards[currentPeerID];				
					var analyzer:PokerHandAnalyzer = new PokerHandAnalyzer(privateCards, this._publicCards, this._handDefinitions);
					newObj.peerID = currentPeerID;
					newObj.analyzer = analyzer;
					this._handAnalyses.push(newObj);
					DebugView.addText(" Peer: " + currentPeerID);
					DebugView.addText("      Highest hand value: " + analyzer.highestHand.totalHandValue);
					if (this._winningScore <  analyzer.highestHand.totalHandValue) {
						this._winningScore = analyzer.highestHand.totalHandValue;						 
						this._winner = currentPeerID;
					}
					var handStr:String = new String();
					var matchStr:String = new String();					
					for (var count2:int = 0; count2 < analyzer.highestHand.matchedHand.length; count2++) {
						handStr += analyzer.highestHand.matchedHand[count2].cardName+", ";
					}
					for (count2 = 0; count2 < analyzer.highestHand.matchedCards.length; count2++) {
						matchStr += analyzer.highestHand.matchedCards[count2].cardName+", ";
					}
					handStr = handStr.substr(0, handStr.length - 2);
					matchStr = matchStr.substr(0, matchStr.length - 2);
					DebugView.addText("      Highest hand: " + handStr);
					DebugView.addText("      Cards in pattern: " + matchStr);
					DebugView.addText("      Evaluated as: " +  analyzer.highestHand.matchedDefinition.@name);
					DebugView.addText("-----------");
				}
				this.compareResults();
			} catch (err:*) {
				DebugView.addText("PokerGameVerifier.scoreHands error:");
				DebugView.addText(err.getStackTrace());				
				this.onVerifyFail();	
			}
		}
		
		/**
		 * Compares generated hand results to determine the winner and to compare against claimed results.
		 */
		private function compareResults():void {
			DebugView.addText("PokerGameVerifier.compareResults");
			DebugView.addText("                Reported winner: " + this._reportedWinner);
			DebugView.addText("    Reported winning hand score: " + this._reportedPlayerHand[this._reportedWinner].value);
			DebugView.addText("                Verified winner: " + this._winner);
			DebugView.addText("    Verified winning hand score: " + this._winningScore);			
			if (this._reportedWinner == this._winner) {
				DebugView.addText("-----------");
				DebugView.addText("Hand fully verified and accurate.");
				if (this._winningScore == (this._reportedPlayerHand[this._reportedWinner].value)) {
					this.onVerifySuccess(false);
				} else {
					this.onVerifySuccess(true);
				}
			} else {
				DebugView.addText("Mismatched results. Verification failed.");
				this.onVerifyFail();
			}			
			this.L1Validate(15);
		}
		
		/**
		 * Invoked when verification fails. If the _autoPopulateContractData property is set to true the verifier will
		 * attempt to populate itself with data from the associated smart contract and start another verification.
		 * 
		 * If this function is invoked a second time (after the verifier has been populated with contract data), or if
		 * _autoPopulateContractData is false, a PokerGameVerifierEvent.FAIL event is dispatched.
		 */
		private function onVerifyFail():void {
			this._verified = false;			
			if (this._autoPopulateContractData && (this._contract != null) && (!this._usingContractData)) {
				//autopopulate must be enabled, contract must exist, and contract must not have yet been used to populate verifier
				setTimeout(this.populateFromContract, 500);
			} else {
				var event:PokerGameVerifierEvent = new PokerGameVerifierEvent(PokerGameVerifierEvent.FAIL);
				this.dispatchEvent(event);
			}
		}
		
		/**
		 * Invoked when verification has successfully completed -- all values were properly decrypted and the verified
		 * winner matches the declared winner. A PokerGameVerifierEvent.SUCCESS event is dispatched by this
		 * method.
		 * 
		 * @param conditional When set to false the resulting event indicates that the verification was unconditinally successful; that is,
		 * all reported values match calculated values. If true then some reported values don't match calculated values but the reported and
		 * verified winner are correct; for example, the reported hand score doesn't match the calculated hand score but the verified results indicate
		 * that the reported winner is still the actuall winner.
		 */
		private function onVerifySuccess(conditional:Boolean = false):void {
			this._verified = true;
			var event:PokerGameVerifierEvent = new PokerGameVerifierEvent(PokerGameVerifierEvent.SUCCESS);
			event.conditional = conditional;
			this.dispatchEvent(event);
		}
		
				/**
		 * Returns a plaintext mapping value for a specified ICard implementation reference. The source CardDeck mappings must already have
		 * been copied to the verifier before calling this function.
		 * 
		 * @param	card An ICard implementation for which to find a plaintext mapping.
		 * 
		 * @return The plaintext mapping value for the associated card, or null if none can be found.
		 */
		private function getCardMapping(card:ICard):String {
			for (var count:int = 0; count < this._cardMaps.length; count++) {
				if ((this._cardMaps[count].card == card) && (this._cardMaps[count].card.frontClassName == card.frontClassName)) {
					return (this._cardMaps[count].mapping);
				}
			}
			return (null);
		}
		
		/**
		 * Returns a fully-encrypted mapping value associated with a plaintext mapping. The plaintext mapping must be that of a card decrypted by
		 * the verifier.
		 * 
		 * @param	plaintextMapping The plaintext card mapping value for which to find an associated fully-encrypted value.
		 * 
		 * @return The fully-encrypted value associated with the plaintext mapping, or null if no such value can be found. Note that only cards
		 * decrypted by the verifier will have a mapping (not the entire deck).
		 */
		private function getEncryptedValue(plaintextMapping:String):String {
			for (var item:String in this._decryptMaps) {
				if (this._decryptMaps[item] == plaintextMapping) {
					return (item);
				}
			}
			return (null);
		}
		
		/**
		 * Returns a validation card index for a specific fully-encrypted card, for a specific account, within the associated smart contract.
		 * Validation card indexes are 0 and 1 for the target account's private/hole cards and 2 to 6 for the public/community cards.
		 * For example, if the encrypted value is the second private card of the target account within the smart contract then 1 is returned. If the
		 * encrypted value is the first public card in the smart contract then 2 is returned.
		 * 
		 * The values generated by this function can be used as the associated smart contract's L1Validate "best cards" indexes.
		 * 
		 * @param	encryptedValue The encrypted value for which to attempt to retrieve an index.
		 * @param	targetAccount The associated accounf for which to attempt to retrieve an index.
		 * 
		 * @return The index of the encrypted value:0 and 1 for private cards and 2 to 6 for public cards. A -1 is returned if no matching
		 * encrypted value exists in the associated smart contract or if the smart contract is inaccessible or null.
		 */
		private function getContractValidationIndex(encryptedValue:String, targetAccount:String):int {
			if (this._contract == null) {
				return ( -1);
			}			
			encryptedValue = encryptedValue.split(" ").join("");			
			encryptedValue = encryptedValue.toLowerCase();
			if (encryptedValue.indexOf("0x") < 0) {
				encryptedValue = "0x" + encryptedValue;
			}
			for (var count:int = 0; count < 2; count++) {
				var currentvalue:String = this._contract.toHex.privateCards(targetAccount, count);
				currentvalue = currentvalue.split(" ").join("");			
				currentvalue = currentvalue.toLowerCase();
				if (currentvalue.indexOf("0x") < 0) {
					currentvalue = "0x" + currentvalue;
				}
				if (currentvalue == encryptedValue) {
					return (count);
				}
			}			
			for (count = 0; count < 5; count++) {
				currentvalue = this._contract.toHex.publicCards(count);
				currentvalue = currentvalue.split(" ").join("");			
				currentvalue = currentvalue.toLowerCase();
				if (currentvalue.indexOf("0x") < 0) {
					currentvalue = "0x" + currentvalue;
				}
				if (currentvalue == encryptedValue) {
					return (count+2);
				}
			}
			return (-1);
		}		
		
		/**
		 * Returns an ISRAMultiKey implementation from a specific player's keychain.
		 * 
		 * @param	peerID The peer ID of the player to retrieve the ISRAMultiKey implementation for.
		 * @param	keyset The key index from the player's keychain.
		 * 
		 * @return An ISRAMultiKey implementation matching the supplied peer ID and index, or null if no such
		 * key can be found.
		 */
		private function getPlayerKey(peerID:String, keyset:int = 0):ISRAMultiKey {
			if (this._playerKeys == null) {
				return (null);
			}
			if ((this._playerKeys[peerID] == undefined) || (this._playerKeys[peerID] == null)) {
				return (null)
			}
			return (this._playerKeys[peerID][keyset] as ISRAMultiKey);
		}
		
		/**
		 * Evaluates a supplied card value for a match to a stored plaintext card value (in _plaintextCards).
		 * 
		 * @param	cardValue The card value to evaluate.
		 * 
		 * @return True if the value matches a stored plaintext card value, false otherwise.
		 */
		private function matchesPlaintextCard(cardValue:String):Boolean {
			if (this._plaintextCards == null) {
				return (false);
			}
			for (var count:int = 0; count < this._plaintextCards.length; count++) {
				if (this._plaintextCards[count] == cardValue) {
					return (true);
				}
			}
			return (false);
		}
		
		/**
		 * Attempts to retrieve an ICard implementation by its plaintext mapping.
		 * 
		 * @param	mapping The plaintext mapping of the card to attempt to retrieve.
		 * 
		 * @return An ICard implementation matching the supplied mapping, or null if no such card/mapping exists.
		 */
		private function getCardByMap(mapping:String):ICard {
			for (var count:int = 0; count < this._cardMaps.length; count++) {
				if (this._cardMaps[count].mapping == mapping) {
					return (this._cardMaps[count].card as ICard);
				}
			}
			return (null);
		}
		
		/**
		 * Attempts to retrieve a PokerHandAnalyzer instance for a specific player.
		 * 
		 * @param	targetPeerID The peer ID of the player for whom to retrieve the analyzer instance for.
		 * 
		 * @return A PokerHandAnalyzer instance used to analyze the hand for the specified player, or null if no
		 * matching instance can be found.
		 */
		private function getPokerHandAnalyzerFor(targetPeerID:String):PokerHandAnalyzer {
			for (var count:int = 0; count < this._handAnalyses.length; count++) {
				if (this._handAnalyses[count].peerID == targetPeerID) {
					return (this._handAnalyses[count].analyzer);
				}
			}
			return (null);
		}
		
		/**
		 * Maps a plaintext or decrypted card to its fully-encrypted value. The cards are mapped internally
		 * in the _decryptMaps object as: _decryptMaps[encryptedValue] = decryptedValue
		 * 
		 * The mapping is accomplished by updating the first found entry that is an empty string
		 * (_decryptMaps[encryptedValue]="").
		 * 
		 * The encrypted value is typically set by one of the verification methods.
		 * 
		 * @param	decryptedCardValue The plaintext or fully decrypted card value to map to an encrypted one.
		 */
		private function mapDecryptedCard(decryptedCardValue:String):void {
			for (var item:String in this._decryptMaps) {								
				if (this._decryptMaps[item] == "") {					
					this._decryptMaps[item] = decryptedCardValue;
					return;
				}
			}
		}
		
		/**
		 * Perpares the verifier instance for removal from memory. 
		 */
		public function destroy():void {
			var event:PokerGameVerifierEvent = new PokerGameVerifierEvent(PokerGameVerifierEvent.DESTROY);
			this.dispatchEvent(event);
			var startingWorker:CryptoWorkerHost = CryptoWorkerHost.nextAvailableCryptoWorker;
			var cryptoWorker:CryptoWorkerHost = null;	
			while (startingWorker != cryptoWorker) {
				cryptoWorker = CryptoWorkerHost.nextAvailableCryptoWorker;
				cryptoWorker.removeEventListener(CryptoWorkerHostEvent.RESPONSE, this.onDecryptPublicCard);	
				cryptoWorker.removeEventListener(CryptoWorkerHostEvent.RESPONSE, this.onDecryptPrivateCard);
			}			
			this._players = null;
			this._nfPlayers = null;
			this._cardMaps = null;
			this._handDefinitions = null;
			this._plaintextCards = null;
			this._encryptedCards = null;
			this._privateCardSelections = null;
			this._publicCardSelections = null;
			this._publicCards = null;
			this._privateCards = null;
			this._playerKeys = null;
			this._decryptMaps = null;
			this._reportedPlayerHand = null;
			this._reportedWinner = null;
			this._winner = null;
			this._winningScore = -1;
			this._playerBestHand = null;
			this._verifying = false;
			this._verified = false;
			this._messageFilter.destroy();
			this._messageFilter = null;
			this._verifyInfo = null;
			this._handAnalyses = null;
			this._game = null;
			this._selfPeerID = null;
			this._contract = null;
			this._resolutionsContract = null;
			this._autoPopulateContractData = false;
			this._usingContractData = false;
			this._cancelL1Validation = false;
			this._verified = false;		
		}
	}
}